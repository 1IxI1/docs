---
title: "Mutability"
---

import { Aside } from '/snippets/aside.jsx';

### Mutability in Tolk vs tilde functions in FunC

<Aside>
  No `~` tilde methods in Tolk.
  For example:
  - `cs.loadInt(32)` modifies a slice and returns an integer.
  - `b.storeInt(x, 32)` modifies a builder.
  - `b = b.storeInt()`  also works because the method returns `self`.

  Method chaining works the same as in JavaScript and produces identical Fift instructions, without runtime overhead.
  Custom methods can also be defined.
</Aside>

In FunC, methods can be called as `.method()` or `~method()`.

In Tolk, all methods use a **dot:** `.method()`. A method _may or may not mutate_ the object.
Tolk defines a mutability model that generalizes the behavior of the `~` tilde in FunC.
Behavior and semantics differ from FunC.

Tolk method calls are designed to behave similarly to JavaScript:

| FunC                                                                      | Tolk                                                           |
|---------------------------------------------------------------------------|----------------------------------------------------------------|
| `int flags = cs~load_uint(32);`                                           | `var flags = cs.loadUint(32);`                                 |
| `(cs, int flags) = cs.load_uint(32);`                                     | `var flags = cs.loadUint(32);`                                 |
| `(slice cs2, int flags) = cs.load_uint(32);`                              | `var cs2 = cs;` `var flags = cs2.loadUint(32);`                |
| `slice data = get_data().begin_parse();` `int flag = data~load_uint(32);` | `val flag = contract.getData().beginParse().loadUint(32);`     |
| `dict~udict_set(...);`                                                    | `dict.set(...);`                                               |
| `b~store_uint(x, 32);`                                                    | `b.storeInt(x, 32);`                                           |
| `b = b.store_int(x, 32);`                                                 | `b.storeInt(x, 32);` // also works  `b = b.storeUint(32);`     |
| `b = b.store_int(x, 32).store_int(y, 32);`                                | `b.storeInt(x, 32).storeInt(y, 32);`  // also works `b = ...;` |


###  All arguments are copied by value by default

```tolk
fun someFn(x: int) {
    x += 1;
}

var origX = 0;
someFn(origX);  // origX remains 0
someFn(10);     // int
origX.someFn(); // still allowed, but not recommended; origX remains 0
```

This also applies to slices, cells, and other types:

```tolk
fun readFlags(cs: slice) {
    return cs.loadInt(32);
}

var flags = readFlags(msgBody);  // msgBody is not modified
// msgBody.loadInt(32) reads the same flags
```

By default, function arguments are copied by value. Function calls **do not** modify the original data.

### mutate keyword and mutating functions

When the `mutate` keyword is added to a parameter, the passed argument becomes mutable. To prevent unintended modifications, `mutate` must also be specified when calling the function.

```tolk
fun increment(mutate x: int) {
    x += 1;
}

// it's correct, simple and straightforward
var origX = 0;
increment(mutate origX);  // origX becomes 1

// these are compiler errors
increment(origX);         // error, unexpected mutation
increment(10);            // error, not lvalue
origX.increment();        // error, not a method, unexpected mutation
val constX = getSome();
increment(mutate constX); // error, it's immutable since `val`
```
This also applies to slices and other types:
```tolk
fun readFlags(mutate cs: slice) {
    return cs.loadInt(32);
}

val flags = readFlags(mutate msgBody);
// msgBody.loadInt(32) will read the next integer
```

A function can define multiple mutate parameters:
```tolk
fun incrementXY(mutate x: int, mutate y: int, byValue: int) {
    x += byValue;
    y += byValue;
}

incrementXY(mutate origX, mutate origY, 10);   // both += 10
```

<Aside>
This behavior is similar to passing by reference, but since ref is already used in TON for cells and slices, the keyword `mutate` is used instead.
</Aside>

### By default, self in methods is immutable

Methods — unlike global functions `fun f()` — are declared as `fun receiver_type.f()`.
If a method accepts `self`, it is an instance method; otherwise, it is static.

```tolk
fun int.assertNotEq(self, throwIfEq: int) {
    if (self == throwIfEq) {
        throw 100;
    }
}

someN.assertNotEq(10);
10.assertNotEq(10);      // also ok, since self is not mutating
```

By default, `self` is immutable. The method cannot modify the object.

```tolk
fun slice.readFlags(self) {
    return self.loadInt(32);  // error, modifying immutable variable
}

fun slice.preloadInt32(self) {
    return self.preloadInt(32);  // ok, it's a read-only method
}
```

Combining `mutate` and `self` defines a mutating method.

### mutate self is a method, called via dot, mutating an object

As follows:
```tolk
fun slice.readFlags(mutate self) {
    return self.loadInt(32);
}

val flags = msgBody.readFlags(); // pretty obvious

fun int.increment(mutate self) {
    self += 1;
}

var origX = 10;
origX.increment();    // 11
10.increment();       // error, not lvalue

// even this is possible
fun int.incrementWithY(mutate self, mutate y: int, byValue: int) {
    self += byValue;
    y += byValue;
}

origX.incrementWithY(mutate origY, 10);   // both += 10
```

If you look into stdlib, you'll notice that many functions actually **mutate self**, meaning they are methods of modifying an object. Tuples, dictionaries, and so on. In FunC, they were usually called via tilde.

```tolk
@pure
fun tuple.push<X>(mutate self, value: X): void
    asm "TPUSH"

t.push(1);
```

### return self makes a method chainable


It is precisely like `return self` in Python or `return this` in JavaScript. That makes methods like `storeInt()` and others chainable.
```tolk
fun builder.storeInt32(mutate self, x: int): self {
    self.storeInt(x, 32);
    return self;

    // this would also work as expected (the same Fift code)
    // return self.storeInt(x, 32);
}

var b = beginCell().storeInt(1, 32).storeInt32(2).storeInt(3, 32);
b.storeInt32(4);     // works without assignment, since mutates b
b = b.storeInt32(5); // and works with assignment, since also returns
```

Pay attention to the return type, it's `self`. You should specify it; otherwise, the compilation will fail if left empty. Probably, in the future, it will be correct.

### mutate self and asm functions


While it's evident for user-defined functions, one could be interested in how to make an `asm` function with such behavior. To answer this question, we should look under the hood at how mutation works inside the compiler.

When a function has `mutate` parameters, it actually implicitly returns them, and they are implicitly assigned to arguments. It's better by example:
```tolk
// actually returns (int, void)
fun increment(mutate x: int): void { ... }

// actually does: (x', _) = increment(x); x = x'
increment(mutate x);

// actually returns (int, int, (slice, cell))
fun f2(mutate x: int, mutate y: int): (slice, cell) { ... }

// actually does: (x', y', r) = f2(x, y); x = x'; y = y'; someF(r)
someF(f2(mutate x, mutate y));

// when `self`, it's the same
// actually does: (cs', r) = loadInt(cs, 32); cs = cs'; flags = r
flags = cs.loadInt(32);
```

So, an `asm` function should place `self'` onto a stack before its return value:
```tolk
// "TPUSH" pops (tuple) and pushes (tuple')
// so, self' = tuple', and return an empty tensor
// `void` is a synonym for an empty tensor
fun tuple.push<X>(mutate self, value: X): void
    asm "TPUSH"

// "LDU" pops (slice) and pushes (int, slice')
// with asm(-> 1 0), we make it (slice', int)
// so, self' = slice', and return int
fun slice.loadMessageFlags(mutate self): int
    asm(-> 1 0) "4 LDU"
```

Note, that to return self, you don't have to do anything special, just specify a return type. The compiler will do the rest.
```tolk
// "STU" pops (int, builder) and pushes (builder')
// with asm(op self), we put arguments to correct order
// so, self' = builder', and return an empty tensor
// but to make it chainable, `self` instead of `void`
fun builder.storeMessageOp(mutate self, op: int): self
    asm(op self) "32 STU"
```

It's doubtful you'll have to do such tricks. Most likely, you'll write wrappers around existing functions:
```tolk
// just do it like this, without asm; it's the same effective

fun slice.myLoadMessageFlags(mutate self): int {
    return self.loadUint(4);
}

fun builder.myStoreMessageOp(mutate self, flags: int): self {
    return self.storeUint(32, flags);
}
```

